<!DOCTYPE html>
<html lang="en">
<head>
    <!-- i hate my life -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Improved Cubing Timer</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* Base styles using CSS variables, applied to the body */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth theme transitions */
        }

        /* Standard (Blue) Theme - Adjusted for sleekness */
        body[data-theme="standard"] {
            --bg-color: #1c212c; /* Slightly darker background */
            --text-color: #e0e6f0; /* Slightly softer light text */
            --container-bg: #28303f; /* Darker gray-800 for container */
            --timer-color: #5aa4f0; /* Brighter, modern blue */
            --timer-ready-color: #f6ad55; /* Orange-400 */
            --timer-holding-color: #a78bfa; /* Purple-400 */
            --manual-mode-color: #a0aec0; /* Gray-500 */
            --scramble-bg: #28303f; /* Container background for consistency */
            --list-border: #3e475a; /* Darker border */
            --solve-time-color: #63b3ed; /* Blue-400 */
            --stat-value-color: #4ade80; /* Brighter green */
            --button-bg: #4a5568; /* Gray-600 */
            --button-hover-bg: #637187; /* Gray-700 */
            --primary-btn-bg: #5aa4f0; /* Brighter blue */
            --primary-btn-hover-bg: #3c82f6; /* Darker blue */
            --danger-btn-bg: #ef4444; /* Red-500 */
            --danger-btn-hover-bg: #dc2626; /* Red-600 */
            --modal-bg: #28303f; /* Container background for consistency */
            --modal-text-color: #e0e6f0; /* Light text */
            --input-bg: #1c212c; /* Dark input background */
            --input-border: #3e475a; /* Dark input border */
            --placeholder-color: #718096; /* Lighter placeholder */
            --canvas-bg: #1c212c; /* Canvas background (not used for drawing scramble anymore) */
            --canvas-border: #3e475a; /* Canvas border (not used for drawing scramble anymore) */
            --input-ring-color: #5aa4f0; /* Blue for input ring */
            --input-ring-color-rgb: 90, 164, 240; /* RGB for Brighter Blue */
        }

        /* Black Theme - Adjusted for sleekness */
        body[data-theme="black"] {
            --bg-color: #0d0d0d; /* Near black */
            --text-color: #f5f5f5; /* Off-white */
            --container-bg: #1a1a1a; /* Darker black */
            --timer-color: #00e0e0; /* Brighter cyan */
            --timer-ready-color: #ffc107; /* Amber */
            --timer-holding-color: #e000e0; /* Brighter magenta */
            --manual-mode-color: #999999; /* Medium gray */
            --scramble-bg: #1a1a1a; /* Darker black */
            --list-border: #333333; /* Dark gray */
            --solve-time-color: #00bfff; /* Deep sky blue */
            --stat-value-color: #39e039; /* Brighter lime green */
            --button-bg: #333333; /* Dark gray */
            --button-hover-bg: #555555; /* Medium gray */
            --primary-btn-bg: #007bff; /* Blue */
            --primary-btn-hover-bg: #0056b3; /* Darker blue */
            --danger-btn-bg: #dc3545; /* Red */
            --danger-btn-hover-bg: #a71d2a; /* Darker red */
            --modal-bg: #1a1a1a; /* Darker black */
            --modal-text-color: #f5f5f5; /* Off-white */
            --input-bg: #0d0d0d; /* Black input background */
            --input-border: #333333; /* Dark input border */
            --placeholder-color: #666666; /* Medium gray placeholder */
            --canvas-bg: #0d0d0d; /* Canvas background (not used for drawing scramble anymore) */
            --canvas-border: #333333; /* Canvas border (not used for drawing scramble anymore) */
            --input-ring-color: #00e0e0; /* Cyan for input ring */
            --input-ring-color-rgb: 0, 224, 224; /* RGB for Brighter Cyan */
        }

        /* White Theme - Adjusted for sleekness */
        body[data-theme="white"] {
            --bg-color: #f8f8f8; /* Off-white */
            --text-color: #222222; /* Darker gray */
            --container-bg: #ffffff; /* Pure white container */
            --timer-color: #2196f3; /* Material blue */
            --timer-ready-color: #ff9800; /* Orange */
            --timer-holding-color: #9c27b0; /* Deep purple */
            --manual-mode-color: #555555; /* Medium gray */
            --scramble-bg: #ffffff; /* Pure white */
            --list-border: #e0e0e0; /* Light gray */
            --solve-time-color: #42a5f5; /* Light blue */
            --stat-value-color: #4caf50; /* Green */
            --button-bg: #e0e0e0; /* Light gray */
            --button-hover-bg: #cccccc; /* Gray */
            --primary-btn-bg: #2196f3; /* Material blue */
            --primary-btn-hover-bg: #1976d2; /* Darker material blue */
            --danger-btn-bg: #f44336; /* Red */
            --danger-btn-hover-bg: #d32f2f; /* Darker red */
            --modal-bg: #ffffff; /* Pure white */
            --modal-text-color: #222222; /* Darker gray */
            --input-bg: #f8f8f8; /* Off-white input background */
            --input-border: #e0e0e0; /* Light input border */
            --placeholder-color: #9e9e9e; /* Even lighter placeholder */
            --canvas-bg: #f8f8f8; /* Canvas background (not used for drawing scramble anymore) */
            --canvas-border: #e0e0e0; /* Canvas border (not used for drawing scramble anymore) */
            --input-ring-color: #2196f3; /* Material blue for input ring */
            --input-ring-color-rgb: 33, 150, 243; /* RGB for Material Blue */
        }

        /* Apply variables to elements */
        .container {
            position: relative;
            max-width: 95%;
            width: 100%;
            padding: 2rem; /* Increased padding */
            margin-top: 2rem; /* Added margin-top to push content down */
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            background-color: var(--container-bg);
            border-radius: 1rem; /* More rounded corners */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15); /* Softer, larger shadow */
        }
        .timer-display {
            font-size: 5.5rem; /* Slightly larger font */
            font-weight: 800; /* Bolder font */
            letter-spacing: -0.05em; /* Tighter letter spacing */
            text-align: center;
            color: var(--timer-color);
            transition: color 0.1s ease-in-out;
            user-select: none;
        }
        .timer-ready {
            color: var(--timer-ready-color);
        }
        .timer-holding {
            color: var(--timer-holding-color);
        }
        .timer-manual-mode {
            color: var(--manual-mode-color);
        }
        .scramble-display {
            font-size: 1.6rem; /* Slightly larger */
            font-weight: 600;
            text-align: center;
            background-color: var(--scramble-bg);
            padding: 1.2rem; /* Increased padding */
            border-radius: 0.8rem; /* More rounded corners */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Softer shadow */
            user-select: none;
        }
        .user-id-display {
            font-size: 0.9rem; /* Slightly larger */
            text-align: center;
            color: var(--manual-mode-color);
            margin-top: 0.75rem; /* More spacing */
            word-break: break-all;
        }
        .solves-list-container {
            background-color: var(--container-bg);
            padding: 1.2rem; /* Increased padding */
            border-radius: 0.8rem; /* More rounded corners */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Softer shadow */
            max-height: 350px; /* Slightly taller */
            overflow-y: auto;
        }
        .solves-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .solves-list li {
            padding: 0.6rem 0; /* More padding */
            border-bottom: 1px solid var(--list-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .solves-list li:last-child {
            border-bottom: none;
        }
        .solve-time {
            font-weight: 700; /* Bolder */
            color: var(--solve-time-color);
        }
        .solve-scramble {
            font-size: 0.9rem; /* Slightly larger */
            color: var(--manual-mode-color);
            flex-grow: 1;
            margin-left: 1.2rem; /* More spacing */
        }
        .delete-solve-btn {
            background-color: var(--danger-btn-bg);
            color: white;
            padding: 0.3rem 0.6rem; /* Slightly larger */
            border-radius: 0.4rem; /* More rounded */
            font-size: 0.8rem; /* Slightly larger */
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s; /* Add transform for subtle click effect */
        }
        .delete-solve-btn:hover {
            background-color: var(--danger-btn-hover-bg);
            transform: translateY(-1px); /* Subtle lift */
        }
        .delete-solve-btn:active {
            transform: translateY(0); /* Press effect */
        }
        .stats-display {
            display: flex;
            justify-content: space-around;
            gap: 1.2rem; /* More spacing */
            margin-top: 1.5rem; /* More spacing */
            flex-wrap: wrap;
        }
        .stat-item {
            background-color: var(--container-bg);
            padding: 0.8rem 1.2rem; /* Increased padding */
            border-radius: 0.8rem; /* More rounded corners */
            text-align: center;
            flex: 1;
            min-width: 130px; /* Slightly wider */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08); /* Subtle shadow */
        }
        .stat-label {
            font-size: 0.9rem; /* Slightly larger */
            color: var(--manual-mode-color);
        }
        .stat-value {
            font-size: 1.35rem; /* Slightly larger */
            font-weight: 800; /* Bolder */
            color: var(--stat-value-color);
        }

        /* Modals (General Styles) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75); /* Slightly darker overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal-overlay.open {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: var(--modal-bg);
            padding: 2.2rem; /* Increased padding */
            border-radius: 1rem; /* More rounded */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4); /* Stronger, more modern shadow */
            width: 90%;
            max-width: 550px; /* Slightly wider */
            transform: translateY(-30px); /* More pronounced slide-in */
            transition: transform 0.3s ease-in-out;
            color: var(--modal-text-color);
            overflow-y: auto; /* Enable scrolling for modal content */
            max-height: 90vh; /* Limit modal height */
        }
        .modal-overlay.open .modal-content {
            transform: translateY(0);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.8rem; /* More spacing */
        }
        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.8rem; /* Larger close button */
            color: var(--manual-mode-color);
            cursor: pointer;
            transition: color 0.2s;
        }
        .modal-close-btn:hover {
            color: var(--text-color); /* Highlight on hover */
        }
        .modal-body label {
            display: block;
            margin-bottom: 0.6rem; /* More spacing */
            color: var(--modal-text-color);
            font-weight: 600;
        }
        .modal-body input[type="number"],
        .modal-body input[type="text"],
        .modal-body select {
            width: 100%;
            padding: 0.9rem; /* Increased padding */
            margin-bottom: 1.2rem; /* More spacing */
            border-radius: 0.6rem; /* More rounded */
            border: 1px solid var(--input-border);
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: border-color 0.2s, box-shadow 0.2s; /* Smooth transitions */
        }
        .modal-body input:focus,
        .modal-body select:focus {
            border-color: var(--input-ring-color);
            box-shadow: 0 0 0 3px rgba(var(--input-ring-color-rgb), 0.3);
            outline: none;
        }
        .modal-body input::placeholder {
            color: var(--placeholder-color);
        }
        .modal-body button {
            width: 100%;
            padding: 0.9rem; /* Increased padding */
            border-radius: 0.6rem; /* More rounded */
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s; /* Add transform and shadow */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .btn-primary {
            background-color: var(--primary-btn-bg);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--primary-btn-hover-bg);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        .btn-primary:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .btn-danger {
            background-color: var(--danger-btn-bg);
            color: white;
            margin-top: 1.5rem; /* More spacing */
        }
        .btn-danger:hover {
            background-color: var(--danger-btn-hover-bg);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        .btn-danger:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .manual-entry-section {
            border-top: 1px solid var(--list-border);
            padding-top: 1.8rem; /* More spacing */
            margin-top: 1.8rem; /* More spacing */
        }

        /* Quick Event Dropdown Specific Styles */
        #quick-event-dropdown {
            position: absolute;
            top: 0;
            left: 0;
            width: auto;
            height: auto;
            background-color: transparent;
            display: block;
            justify-content: flex-start;
            align-items: flex-start;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: none;
        }
        #quick-event-dropdown.open {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }
        #quick-event-dropdown .modal-content {
            position: absolute;
            top: 4rem; /* Adjusted position */
            left: 1.5rem; /* Adjusted position */
            max-width: 220px; /* Slightly wider */
            padding: 1.2rem; /* Adjusted padding */
            transform: none;
            transition: none;
        }
        #quick-event-dropdown.open .modal-content {
            transform: none;
        }
        #quick-event-dropdown .modal-body {
            padding: 0;
        }
        #quick-event-dropdown .modal-body select {
            margin-bottom: 0;
        }
        #quick-event-toggle-btn {
            position: absolute;
            top: 1rem; /* Adjusted position */
            left: 1.5rem; /* Adjusted position */
            z-index: 1001;
            background-color: var(--button-bg);
            color: var(--text-color);
            padding: 0.6rem 1rem; /* Adjusted padding */
            border-radius: 0.6rem; /* More rounded */
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
        }
        #quick-event-toggle-btn:hover {
            background-color: var(--button-hover-bg);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        #quick-event-toggle-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Sessions Button Specific Styles */
        #sessions-btn {
            position: absolute;
            top: 1rem;
            left: 10rem; /* Positioned to the right of quick-event-toggle-btn */
            padding: 0.6rem 1rem;
            font-size: 0.9rem;
            z-index: 1001;
            width: auto;
            background-color: var(--button-bg);
            color: var(--text-color);
            border-radius: 0.6rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
        }
        #sessions-btn:hover {
            background-color: var(--button-hover-bg);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        #sessions-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Settings Button Specific Styles */
        #settings-btn {
            position: absolute;
            top: 1rem; /* Adjusted position */
            right: 1.5rem; /* Adjusted position */
            padding: 0.6rem 1rem; /* Adjusted padding */
            font-size: 0.9rem; /* Slightly larger */
            z-index: 1001;
            width: auto;
            background-color: var(--button-bg);
            color: var(--text-color);
            border-radius: 0.6rem; /* More rounded */
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
        }
        #settings-btn:hover {
            background-color: var(--button-hover-bg);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        #settings-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Scramble Navigation Buttons */
        .scramble-nav-buttons {
            display: flex;
            justify-content: center;
            gap: 1.2rem; /* More spacing */
            margin-top: 1.5rem; /* More spacing */
        }
        .scramble-nav-buttons button {
            padding: 0.8rem 1.8rem; /* Increased padding */
            border-radius: 0.6rem; /* More rounded */
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            background-color: var(--button-bg);
            color: var(--text-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .scramble-nav-buttons button:hover:not(:disabled) {
            background-color: var(--button-hover-bg);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        .scramble-nav-buttons button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .scramble-nav-buttons button:disabled {
            opacity: 0.4; /* Slightly more opaque disabled state */
            cursor: not-allowed;
            box-shadow: none;
        }

        /* New manual timer input style */
        #manual-timer-main-input {
            font-size: 5.5rem; /* Slightly larger font */
            font-weight: 800; /* Bolder font */
            letter-spacing: -0.05em; /* Tighter letter spacing */
            text-align: center;
            background-color: transparent;
            border: 2px solid transparent; /* Default transparent border */
            outline: none;
            width: 100%;
            padding: 0;
            margin: 0;
            box-shadow: none;
            color: var(--manual-mode-color);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        #manual-timer-main-input:focus {
            border-color: var(--input-ring-color);
            box-shadow: 0 0 0 4px rgba(var(--input-ring-color-rgb), 0.4);
            border-radius: 0.6rem;
        }
        #manual-timer-main-input::placeholder {
            color: var(--placeholder-color);
        }

        /* Settings Modal Sections */
        .settings-section {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--list-border);
        }

        .settings-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .settings-section h3 {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--primary-btn-bg);
            margin-bottom: 1.2rem;
        }

        /* Camera Feed */
        #camera-feed {
            width: 200px;
            height: 150px;
            object-fit: cover;
            background-color: black;
            border: 1px solid var(--canvas-border);
            margin: 1rem auto;
            border-radius: 0.8rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        #camera-feed.hidden {
            display: none;
        }

        /* Custom Toggle Switch for Camera */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
            margin-bottom: 1.2rem;
            vertical-align: middle;
            margin-left: 0.5rem;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--input-border);
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: var(--input-bg);
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary-btn-bg);
        }

        input:focus + .toggle-slider {
            box-shadow: 0 0 1px var(--primary-btn-bg);
        }

        input:checked + .toggle-slider:before {
            -webkit-transform: translateX(16px);
            -ms-transform: translateX(16px);
            transform: translateX(16px);
        }

        /* AI Feedback Display */
        #ai-feedback-display {
            text-align: center;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--stat-value-color); /* Green for good, maybe red for bad */
            margin-top: 1rem;
            min-height: 1.5rem; /* Reserve space */
        }
        #ai-feedback-display.error {
            color: var(--danger-btn-bg);
        }

        /* Sessions Modal specific styles */
        #sessions-modal .modal-content {
            max-width: 600px;
        }
        #sessions-list-container {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid var(--list-border);
            border-radius: 0.6rem;
            margin-bottom: 1.5rem;
            padding: 0.5rem;
        }
        #sessions-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 0.5rem;
            border-bottom: 1px solid var(--list-border);
        }
        #sessions-list li:last-child {
            border-bottom: none;
        }
        #sessions-list li.active-session {
            background-color: rgba(var(--input-ring-color-rgb), 0.1);
            border-radius: 0.4rem;
        }
        .session-name {
            flex-grow: 1;
            font-weight: 600;
        }
        .session-actions button {
            width: auto;
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
            margin-left: 0.5rem;
            box-shadow: none; /* Remove individual button shadow */
        }
        .session-actions button:hover {
            transform: none; /* Remove individual button transform */
            box-shadow: none;
        }
        .session-actions {
            display: flex;
            gap: 0.5rem;
        }
        #create-session-section {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--list-border);
        }
        #create-session-section input {
            margin-bottom: 1rem;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .timer-display, #manual-timer-main-input {
                font-size: 3.8rem;
            }
            .scramble-display {
                font-size: 1.3rem;
                padding: 0.8rem;
            }
            .container {
                padding: 1.2rem;
                gap: 1rem;
                margin-top: 1.5rem; /* Adjusted for smaller screens */
            }
            .stats-display {
                flex-direction: column;
                gap: 0.8rem;
                margin-top: 1rem;
            }
            .stat-item {
                width: 100%;
                min-width: unset;
                padding: 0.6rem 0.8rem;
            }
            .modal-content {
                padding: 1.8rem;
            }
            #quick-event-toggle-btn {
                top: 0.8rem;
                left: 0.8rem;
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
            #quick-event-dropdown .modal-content {
                top: 3.5rem;
                left: 0.8rem;
            }
            #sessions-btn {
                top: 0.8rem;
                left: 7rem; /* Adjust position for smaller screens */
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
            #settings-btn {
                top: 0.8rem;
                right: 0.8rem;
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
            .scramble-nav-buttons button {
                padding: 0.6rem 1.2rem;
                font-size: 0.85rem;
            }
            .user-id-display {
                font-size: 0.8rem;
            }
            .settings-section h3 {
                font-size: 1.2rem;
            }
            #sessions-list li {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
            .session-actions {
                width: 100%;
                justify-content: flex-end;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- New quick event toggle button -->
        <button id="quick-event-toggle-btn" class="p-2 rounded-lg shadow-md">
            Change Event
        </button>

        <!-- New Sessions button -->
        <button id="sessions-btn" class="p-2 rounded-lg shadow-md">
            Sessions
        </button>

        <!-- Settings button, now in top right -->
        <button id="settings-btn" class="py-3 rounded-lg mt-4">Settings</button>

        <!-- Camera Feed Display -->
        <div class="flex flex-col items-center">
            <video id="camera-feed" class="hidden" autoplay playsinline muted></video>
            <span id="recording-status" class="hidden text-red-500 font-bold ml-2">REC</span>
        </div>

        <!-- AI Feedback Display -->
        <div id="ai-feedback-display"></div>


        <div id="scramble-display" class="scramble-display">Generating Scramble...</div>
        <!-- Scramble Canvas removed -->

        <!-- Scramble Navigation Buttons -->
        <div class="scramble-nav-buttons">
            <button id="last-scramble-btn" disabled>Last</button>
            <button id="next-scramble-btn">Next</button>
        </div>

        <!-- Timer Display / Manual Input Container -->
        <div id="timer-container">
            <div id="timer-display" class="timer-display">0.000</div>
            <input type="text" id="manual-timer-main-input" class="hidden">
        </div>
        
        <div class="flex flex-col items-center mt-2">
            <span id="user-id-display" class="user-id-display">Loading User ID...</span>
            <span id="wca-id-display" class="user-id-display mt-1">WCA ID: N/A</span>
            <span id="current-session-name-display" class="user-id-display mt-1">Session: Default</span>
        </div>

        <div class="stats-display">
            <div class="stat-item">
                <div class="stat-label">Solves</div>
                <div id="total-solves" class="stat-value">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Best Time</div>
                <div id="best-time" class="stat-value">N/A</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Average</div>
                <div id="average-time" class="stat-value">N/A</div>
            </div>
            <!-- New Statistics -->
            <div class="stat-item">
                <div class="stat-label">Best Ao5</div>
                <div id="best-ao5" class="stat-value">N/A</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Ao12</div>
                <div id="ao12" class="stat-value">N/A</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Ao25</div>
                <div id="ao25" class="stat-value">N/A</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Ao50</div>
                <div id="ao50" class="stat-value">N/A</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Ao100</div>
                <div id="ao100" class="stat-value">N/A</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Ao200</div>
                <div id="ao200" class="stat-value">N/A</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Ao500</div>
                <div id="ao500" class="stat-value">N/A</div>
            </div>
        </div>

        <div class="solves-list-container">
            <h3 class="text-xl font-semibold mb-4 text-center text-blue-300">Solve History</h3>
            <ul id="solves-list" class="solves-list">
                <!-- Solves will be dynamically added here -->
            </ul>
        </div>
    </div>

    <!-- Quick Event Dropdown/Modal (initially hidden) -->
    <div id="quick-event-dropdown" class="modal-overlay hidden">
        <div class="modal-content !max-w-xs !p-4">
            <div class="modal-header !mb-2">
                <h3 class="text-xl font-bold">Select Event</h3>
                <button id="close-quick-event-btn" class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <!-- The event-select will be moved here dynamically -->
            </div>
        </div>
    </div>

    <!-- Sessions Modal -->
    <div id="sessions-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="text-2xl font-bold">Manage Sessions</h2>
                <button id="close-sessions-btn" class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <h3 class="text-xl font-semibold mb-3">Your Sessions</h3>
                <div id="sessions-list-container">
                    <ul id="sessions-list">
                        <!-- Sessions will be dynamically added here -->
                    </ul>
                </div>

                <div id="create-session-section">
                    <h3 class="text-xl font-semibold mb-3">Create New Session</h3>
                    <label for="new-session-name-input">Session Name:</label>
                    <input type="text" id="new-session-name-input" placeholder="e.g., 3x3 Practice, BLD Training">
                    <button id="create-session-btn" class="btn-primary">Create Session</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="text-2xl font-bold">Settings</h2>
                <button id="close-settings-btn" class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Timer Settings Section -->
                <div class="settings-section">
                    <h3>Timer Settings</h3>
                    <label for="hold-time-threshold">Timer Hold Time (ms):</label>
                    <input type="number" id="hold-time-threshold" min="100" max="2000" value="500">

                    <!-- New timer mode toggle button -->
                    <button id="toggle-timer-mode-btn" class="btn-primary mt-4 mb-4">Switch to Manual Entry</button>
                </div>

                <!-- Scramble Settings Section -->
                <div class="settings-section">
                    <h3>Scramble Settings</h3>
                    <label for="scramble-length">Scramble Length (Current Event):</label>
                    <input type="number" id="scramble-length" min="10" max="50" value="20">
                    <!-- The event-select will be moved here dynamically -->
                </div>

                <!-- Display Settings Section -->
                <div class="settings-section">
                    <h3>Display Settings</h3>
                    <!-- New Theme Selection -->
                    <label for="theme-select">Theme:</label>
                    <select id="theme-select">
                        <option value="standard">Standard (Blue)</option>
                        <option value="black">Black</option>
                        <option value="white">White</option>
                    </select>
                </div>

                <!-- Camera Settings Section -->
                <div class="settings-section">
                    <h3>Camera Settings</h3>
                    <label for="camera-toggle">Enable Camera:
                        <label class="toggle-switch">
                            <input type="checkbox" id="camera-toggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </label>
                    <button id="start-recording-btn" class="btn-primary mt-4">Start Recording</button>
                    <button id="stop-recording-btn" class="btn-danger mt-2" disabled>Stop Recording</button>
                </div>

                <!-- Data Management Section -->
                <div class="settings-section">
                    <h3>Data Management</h3>
                    <!-- WCA ID Input -->
                    <label for="wca-id-input">WCA ID (Optional):</label>
                    <input type="text" id="wca-id-input" placeholder="Enter your WCA ID">
                    <button id="save-wca-id-btn" class="btn-primary mb-4">Save WCA ID</button>

                    <div class="manual-entry-section">
                        <h3 class="text-xl font-semibold">Manual Time Entry (for arbitrary solves)</h3>
                        <label for="manual-time-input">Enter Time (e.g., 10.5, 1:23.45):</label>
                        <input type="text" id="manual-time-input">
                        <button id="add-manual-solve-btn" class="btn-primary">Add Manual Solve</button>
                    </div>

                    <button id="clear-solves-btn" class="btn-danger">Clear All Solves for Current Session</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal (for clearing solves or deleting session) -->
    <div id="confirmation-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="text-xl font-bold">Confirm Action</h2>
                <button id="close-confirmation-btn" class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <p id="confirmation-message" class="mb-4">Are you sure you want to proceed?</p>
                <div class="flex justify-end gap-4">
                    <button id="cancel-action-btn" class="btn-primary bg-gray-600 hover:bg-gray-700 w-1/2">Cancel</button>
                    <button id="confirm-action-btn" class="btn-danger w-1/2">Confirm</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Camera Permission Denied Modal -->
    <div id="camera-permission-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="text-xl font-bold">Camera Access Denied</h2>
                <button id="close-camera-permission-modal-btn" class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <p class="mb-4">It looks like camera access was denied. To enable the camera, please follow these steps:</p>
                <ul class="list-disc list-inside mb-4">
                    <li><strong>For Chrome/Edge:</strong> Click the camera icon in the address bar (usually on the right side), then select "Always allow" or "Continue allowing" and refresh the page.</li>
                    <li><strong>For Firefox:</strong> Click the camera icon in the address bar, then select "Allow" or "Always Allow" and refresh the page.</li>
                    <li><strong>For Safari:</strong> Go to Safari > Settings > Websites > Camera, and set "cubing-timer-app" to "Allow". You may need to refresh the page.</li>
                    <li><strong>General:</strong> Check your operating system's privacy settings to ensure camera access is enabled for your browser.</li>
                </ul>
                <p>After granting permission, please try enabling the camera again in the settings.</p>
                <button id="ok-camera-permission-btn" class="btn-primary mt-4">OK</button>
            </div>
        </div>
    </div>


    <!-- The standalone event-select element - hidden by default, moved dynamically -->
    <select id="event-select" class="hidden">
        <option value="3x3">3x3x3 Cube</option>
        <option value="2x2">2x2x2 Cube</option>
        <option value="4x4">4x4x4 Cube</option>
        <option value="5x5">5x5x5 Cube</option>
        <option value="6x6">6x6x6 Cube</option>
        <option value="7x7">7x7x7 Cube</option>
        <option value="Clock">Clock</option>
        <option value="Megaminx">Megaminx</option>
        <option value="Pyraminx">Pyraminx</option>
        <option value="Skewb">Skewb</option>
        <option value="Square-1">Square-1</option>
        <option value="3x3 OH">3x3x3 One-Handed</option>
        <option value="3x3 BLD">3x3x3 Blindfolded</option>
        <option value="3x3 Multi-BLD">3x3x3 Multi-Blind</option>
        <option value="FTO">FTO</option>
    </select>

    <!-- Hidden canvas for capturing video frames -->
    <canvas id="capture-canvas" style="display:none;"></canvas>


    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables for Firebase and app state
        let app;
        let db;
        let auth;
        let userId;
        let isAuthReady = false; // Flag to ensure Firestore operations wait for auth

        // Timer state variables
        let timerInterval;
        let startTime;
        let elapsedTime = 0; // In milliseconds
        let running = false;
        let spacebarDownTime = 0; // To track how long spacebar is held
        let readyToStart = false; // Flag to indicate timer is ready to start
        
        // Customizable settings
        let scrambleLength = 20; // Default scramble length
        let holdTimeThreshold = 500; // Default milliseconds to hold spacebar to start
        let currentEvent = '3x3'; // Default event
        let timerMode = 'keyboard'; // 'keyboard' or 'manual'
        let currentTheme = 'standard'; // Default theme
        let wcaId = ''; // New: WCA ID variable
        let cameraEnabled = false; // New: Camera enabled state
        let mediaStream = null; // Stores the camera media stream
        let mediaRecorder = null; // New: MediaRecorder instance
        let recordedChunks = []; // New: Array to store recorded video chunks
        let recording = false; // New: Flag to indicate if recording is active

        // Session management variables
        let currentSessionId = null;
        let currentSessionName = 'Default Session';
        let sessions = []; // Array to hold session objects { id, name, createdAt, ...settings }

        // Scramble and solve data
        let currentScramble = '';
        let solves = [];
        let scrambleHistory = []; // Array to store generated scrambles
        let currentScrambleIndex = -1; // Index of the currently displayed scramble in history

        // DOM elements
        const timerDisplay = document.getElementById('timer-display');
        const manualTimerMainInput = document.getElementById('manual-timer-main-input'); // New element
        const scrambleDisplay = document.getElementById('scramble-display');
        const userIdDisplay = document.getElementById('user-id-display');
        const wcaIdDisplay = document.getElementById('wca-id-display'); // New WCA ID display
        const currentSessionNameDisplay = document.getElementById('current-session-name-display'); // New session name display
        const solvesList = document.getElementById('solves-list');
        const totalSolvesDisplay = document.getElementById('total-solves');
        const bestTimeDisplay = document.getElementById('best-time');
        const averageTimeDisplay = document.getElementById('average-time');
        const cameraFeed = document.getElementById('camera-feed'); // New camera feed element
        const recordingStatusDisplay = document.getElementById('recording-status'); // New recording status display
        const aiFeedbackDisplay = document.getElementById('ai-feedback-display'); // New AI feedback display
        const captureCanvas = document.getElementById('capture-canvas'); // Hidden canvas for frame capture
        const captureCtx = captureCanvas.getContext('2d'); // Context for hidden canvas

        // New stats display elements
        const bestAo5Display = document.getElementById('best-ao5');
        const ao12Display = document.getElementById('ao12');
        const ao25Display = document.getElementById('ao25');
        const ao50Display = document.getElementById('ao50');
        const ao100Display = document.getElementById('ao100');
        const ao200Display = document.getElementById('ao200');
        const ao500Display = document.getElementById('ao500');

        // Settings modal elements
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const scrambleLengthInput = document.getElementById('scramble-length');
        const holdTimeThresholdInput = document.getElementById('hold-time-threshold');
        const clearSolvesBtn = document.getElementById('clear-solves-btn');
        const manualTimeInput = document.getElementById('manual-time-input'); // Input inside settings modal
        const addManualSolveBtn = document.getElementById('add-manual-solve-btn');
        const toggleTimerModeBtn = document.getElementById('toggle-timer-mode-btn'); // New button
        const themeSelect = document.getElementById('theme-select'); // New theme select element
        const wcaIdInput = document.getElementById('wca-id-input'); // New WCA ID input
        const saveWcaIdBtn = document.getElementById('save-wca-id-btn'); // New Save WCA ID button
        const cameraToggle = document.getElementById('camera-toggle'); // New camera toggle switch
        const startRecordingBtn = document.getElementById('start-recording-btn'); // New recording button
        const stopRecordingBtn = document.getElementById('stop-recording-btn'); // New recording button

        // Quick Event Select elements
        const quickEventToggleBtn = document.getElementById('quick-event-toggle-btn');
        const quickEventDropdown = document.getElementById('quick-event-dropdown');
        const closeQuickEventBtn = document.getElementById('close-quick-event-btn');
        const eventSelect = document.getElementById('event-select'); // This will be moved dynamically

        // Scramble Navigation Buttons
        const lastScrambleBtn = document.getElementById('last-scramble-btn');
        const nextScrambleBtn = document.getElementById('next-scramble-btn');

        // Sessions modal elements
        const sessionsBtn = document.getElementById('sessions-btn');
        const sessionsModal = document.getElementById('sessions-modal');
        const closeSessionsBtn = document.getElementById('close-sessions-btn');
        const sessionsList = document.getElementById('sessions-list'); // Renamed from solvesList
        const newSessionNameInput = document.getElementById('new-session-name-input');
        const createSessionBtn = document.getElementById('create-session-btn');


        // Confirmation modal elements
        const confirmationModal = document.getElementById('confirmation-modal');
        const closeConfirmationBtn = document.getElementById('close-confirmation-btn');
        const cancelActionButton = document.getElementById('cancel-action-btn');
        const confirmActionButton = document.getElementById('confirm-action-btn');
        const confirmationMessage = document.getElementById('confirmation-message');
        let currentConfirmAction = null; // Stores the function to call on confirmation

        // Camera Permission Denied Modal elements
        const cameraPermissionModal = document.getElementById('camera-permission-modal');
        const closeCameraPermissionModalBtn = document.getElementById('close-camera-permission-modal-btn');
        const okCameraPermissionBtn = document.getElementById('ok-camera-permission-btn');

        // --- Firebase Initialization and Authentication ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

        // Initialize Firebase
        if (Object.keys(firebaseConfig).length > 0) {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            // Listen for authentication state changes
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    userIdDisplay.textContent = `User ID: ${userId}`;
                    console.log("User signed in:", userId);
                    isAuthReady = true;
                    await initializeUserSessions(); // New: Initialize sessions for the user
                    updateTimerModeUI(); // Update UI based on loaded timer mode
                    updateWCAIdDisplay(); // Update WCA ID display
                    if (cameraEnabled) {
                        enableCamera();
                    }
                } else {
                    try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(auth, __initial_auth_token);
                            console.log("Signed in with custom token.");
                        } else {
                            await signInAnonymously(auth);
                            console.log("Signed in anonymously.");
                        }
                    } catch (error) {
                        console.error("Firebase authentication error:", error);
                        userIdDisplay.textContent = "Authentication Error!";
                    }
                }
            });
        } else {
            console.error("Firebase config is not provided. Firestore features will not be available.");
            userIdDisplay.textContent = "Firestore Disabled (No Config)";
            isAuthReady = true; // Allow app to run without Firestore
            generateScramble(true); // Generate initial scramble
            updateTimerModeUI(); // Update UI for default timer mode
            applyTheme(currentTheme); // Apply default theme if no Firebase
            updateWCAIdDisplay(); // Update WCA ID display
            currentSessionNameDisplay.textContent = `Session: ${currentSessionName}`; // Display default session name
        }

        // --- Session Management Logic ---

        async function initializeUserSessions() {
            if (!db || !userId || !isAuthReady) return;

            // Load user-level settings to get the last active session
            const userSettingsDocRef = doc(db, `artifacts/${appId}/users/${userId}/settings/userSettings`);
            const userSettingsSnap = await getDoc(userSettingsDocRef);
            let lastActiveSessionId = null;
            if (userSettingsSnap.exists()) {
                lastActiveSessionId = userSettingsSnap.data().lastActiveSessionId;
            }

            // Load all sessions for the user
            const sessionsCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/sessions`);
            onSnapshot(sessionsCollectionRef, async (snapshot) => {
                sessions = [];
                snapshot.forEach(doc => {
                    sessions.push({ id: doc.id, ...doc.data() });
                });
                sessions.sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0)); // Sort by creation time

                if (sessions.length === 0) {
                    // No sessions exist, create a default one
                    await createSession('Default Session', true);
                } else {
                    let sessionToSelect = sessions[0]; // Default to the first session
                    if (lastActiveSessionId) {
                        const foundSession = sessions.find(s => s.id === lastActiveSessionId);
                        if (foundSession) {
                            sessionToSelect = foundSession;
                        }
                    }
                    await selectSession(sessionToSelect.id, sessionToSelect.name, false); // Select without saving lastActiveSessionId again
                }
                updateSessionsListUI();
            }, (error) => {
                console.error("Error loading sessions:", error);
            });
        }

        async function createSession(name, makeActive = true) {
            if (!db || !userId || !isAuthReady) return;
            try {
                const sessionsCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/sessions`);
                const newSessionRef = await addDoc(sessionsCollectionRef, {
                    name: name,
                    createdAt: Date.now(),
                    currentEvent: '3x3',
                    scrambleLength: 20,
                    holdTimeThreshold: 500,
                    theme: 'standard',
                    wcaId: '',
                    cameraEnabled: false
                });
                console.log("New session created:", newSessionRef.id);
                if (makeActive) {
                    await selectSession(newSessionRef.id, name);
                }
            } catch (e) {
                console.error("Error creating session:", e);
            }
        }

        async function selectSession(sessionId, sessionName, saveLastActive = true) {
            if (!db || !userId || !isAuthReady) return;
            if (currentSessionId === sessionId) {
                console.log("Session already active.");
                return;
            }

            currentSessionId = sessionId;
            currentSessionName = sessionName;
            currentSessionNameDisplay.textContent = `Session: ${currentSessionName}`;
            console.log(`Switched to session: ${currentSessionName} (${currentSessionId})`);

            // Load settings for the new session
            await loadSettingsForCurrentSession();
            // Load solves for the new session
            loadSolvesForCurrentSession();

            if (saveLastActive) {
                // Save the currently active session ID to user-level settings
                const userSettingsDocRef = doc(db, `artifacts/${appId}/users/${userId}/settings/userSettings`);
                await setDoc(userSettingsDocRef, { lastActiveSessionId: sessionId }, { merge: true });
            }
            closeAllModals();
        }

        async function renameSession(sessionId, newName) {
            if (!db || !userId || !isAuthReady) return;
            try {
                const sessionDocRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, sessionId);
                await updateDoc(sessionDocRef, { name: newName });
                console.log(`Session ${sessionId} renamed to ${newName}`);
                if (sessionId === currentSessionId) {
                    currentSessionName = newName;
                    currentSessionNameDisplay.textContent = `Session: ${currentSessionName}`;
                }
                updateSessionsListUI(); // Refresh UI
            } catch (e) {
                console.error("Error renaming session:", e);
            }
        }

        async function deleteSession(sessionIdToDelete) {
            if (!db || !userId || !isAuthReady) return;
            if (sessionIdToDelete === currentSessionId) {
                console.warn("Cannot delete the currently active session. Please switch to another session first.");
                showConfirmation("Cannot delete the active session. Please switch to another session first.", "OK", () => {}, true); // Show a simple alert
                return;
            }
            
            showConfirmation("Are you sure you want to delete this session and ALL its solves? This action cannot be undone.", "Delete", async () => {
                try {
                    // 1. Delete all solves within the session's subcollection
                    const solvesCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/sessions/${sessionIdToDelete}/solves`);
                    const q = query(solvesCollectionRef);
                    const querySnapshot = await getDocs(q);
                    const batch = writeBatch(db);
                    querySnapshot.forEach((document) => {
                        batch.delete(document.ref);
                    });
                    await batch.commit();
                    console.log(`All solves for session ${sessionIdToDelete} deleted.`);

                    // 2. Delete the session document itself
                    const sessionDocRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, sessionIdToDelete);
                    await deleteDoc(sessionDocRef);
                    console.log(`Session ${sessionIdToDelete} deleted.`);

                    // If the deleted session was the last active one, switch to default or first available
                    if (sessionIdToDelete === currentSessionId) {
                        // This case should be prevented by the check at the start of the function
                        // but as a fallback, select the first available session
                        if (sessions.length > 0) {
                            await selectSession(sessions[0].id, sessions[0].name);
                        } else {
                            await createSession('Default Session', true);
                        }
                    }
                    updateSessionsListUI(); // Refresh UI
                } catch (e) {
                    console.error("Error deleting session and its solves:", e);
                    showConfirmation("Error deleting session. Please try again.", "OK", () => {}, true);
                }
            });
        }

        function updateSessionsListUI() {
            sessionsList.innerHTML = '';
            if (sessions.length === 0) {
                sessionsList.innerHTML = '<li class="text-center text-gray-400">No sessions yet. Create one!</li>';
                return;
            }
            sessions.forEach(session => {
                const li = document.createElement('li');
                li.dataset.sessionId = session.id;
                li.classList.add('flex', 'flex-wrap', 'items-center', 'justify-between', 'gap-2');
                if (session.id === currentSessionId) {
                    li.classList.add('active-session');
                }

                const sessionNameSpan = document.createElement('span');
                sessionNameSpan.classList.add('session-name', 'flex-grow');
                sessionNameSpan.textContent = session.name;

                const sessionActionsDiv = document.createElement('div');
                sessionActionsDiv.classList.add('session-actions', 'flex-shrink-0');

                const selectBtn = document.createElement('button');
                selectBtn.textContent = 'Select';
                selectBtn.classList.add('btn-primary');
                selectBtn.addEventListener('click', () => selectSession(session.id, session.name));

                const renameBtn = document.createElement('button');
                renameBtn.textContent = 'Rename';
                renameBtn.classList.add('btn-primary', 'bg-yellow-600', 'hover:bg-yellow-700');
                renameBtn.addEventListener('click', () => {
                    const newName = prompt(`Enter new name for "${session.name}":`);
                    if (newName && newName.trim() !== '') {
                        renameSession(session.id, newName.trim());
                    }
                });

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('btn-danger');
                deleteBtn.addEventListener('click', () => deleteSession(session.id));

                sessionActionsDiv.appendChild(selectBtn);
                sessionActionsDiv.appendChild(renameBtn);
                sessionActionsDiv.appendChild(deleteBtn);

                li.appendChild(sessionNameSpan);
                li.appendChild(sessionActionsDiv);
                sessionsList.appendChild(li);
            });
        }

        // --- Theme Application Logic ---
        function applyTheme(themeName) {
            document.body.setAttribute('data-theme', themeName);
            currentTheme = themeName; // Update global theme variable
        }

        // --- Timer Logic ---

        // Formats milliseconds into a readable time string (MM:SS.mmm)
        function formatTime(ms, isDnf = false, plusTwo = false) {
            if (isDnf) return 'DNF';
            let formattedTime = '';
            const minutes = Math.floor(ms / 60000);
            const seconds = Math.floor((ms % 60000) / 1000);
            const milliseconds = Math.floor((ms % 1000));

            if (minutes > 0) {
                formattedTime += `${minutes}:`;
            }
            formattedTime += `${seconds.toString().padStart(minutes > 0 ? 2 : 1, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            
            if (plusTwo) {
                formattedTime += '+';
            }
            return formattedTime;
        }

        // Updates the timer display
        function updateTimerDisplay() {
            if (running) {
                elapsedTime = Date.now() - startTime;
            }
            timerDisplay.textContent = formatTime(elapsedTime);
            if (running) {
                requestAnimationFrame(updateTimerDisplay);
            }
        }

        // Starts the timer
        function startTimer() {
            if (!running) {
                startTime = Date.now();
                running = true;
                timerDisplay.classList.remove('timer-ready', 'timer-holding', 'timer-manual-mode');
                timerDisplay.style.color = 'var(--timer-color)'; // Use CSS variable
                requestAnimationFrame(updateTimerDisplay);

                // AI Feature: Capture image and analyze on timer start
                if (cameraEnabled && mediaStream && cameraFeed.readyState === 4) { // Check if video is ready
                    analyzeStartImage();
                } else if (cameraEnabled) {
                    aiFeedbackDisplay.textContent = "Camera not ready for AI analysis.";
                    aiFeedbackDisplay.classList.add('error');
                }
            }
        }

        // Stops the timer
        function stopTimer() {
            if (running) {
                running = false;
                clearInterval(timerInterval); // Clear any old interval if it was used
                elapsedTime = Date.now() - startTime;
                timerDisplay.textContent = formatTime(elapsedTime);
                saveSolve(elapsedTime, currentScramble, currentEvent); // Save the solve with event
                generateScramble(true); // Generate new scramble for next solve, add to history
            }
        }

        // Resets the timer
        function resetTimer() {
            stopTimer(); // Ensure timer is stopped
            elapsedTime = 0;
            timerDisplay.textContent = '0.000';
            manualTimerMainInput.value = ''; // Changed: Clear the input box
            manualTimerMainInput.style.borderColor = 'transparent'; // Reset border
            manualTimerMainInput.style.boxShadow = 'none'; // Reset shadow
            timerDisplay.classList.remove('timer-ready', 'timer-holding');
            if (timerMode === 'manual') {
                timerDisplay.classList.add('timer-manual-mode');
                manualTimerMainInput.classList.add('timer-manual-mode');
            } else {
                timerDisplay.style.color = 'var(--timer-color)'; // Reset to blue (or theme color)
            }
            running = false;
            readyToStart = false;
            spacebarDownTime = 0;
            aiFeedbackDisplay.textContent = ''; // Clear AI feedback on reset
            aiFeedbackDisplay.classList.remove('error');
        }

        // --- Scramble Generation ---

        function getScrambleLengthForEvent(eventType) {
            switch (eventType) {
                case '2x2': return 9; // WCA typically 9 moves
                case '3x3':
                case '3x3 OH':
                case '3x3 BLD':
                case '3x3 Multi-BLD': return 20; // WCA typically 20-25 moves, 20 is common
                case '4x4': return 40; // WCA typically 40-45 moves
                case '5x5': return 60; // WCA typically 60 moves
                case '6x6': return 80; // WCA typically 80 moves
                case '7x7': return 100; // WCA typically 100 moves
                case 'Clock': return 10; // Clock scrambles are complex, 10-15 moves
                case 'Megaminx': return 70; // WCA typically 70 moves
                case 'Pyraminx': return 10; // WCA typically 10-12 moves
                case 'Skewb': return 10; // WCA typically 10-12 moves
                case 'Square-1': return 10; // Square-1 scrambles are complex, 10-15 slices
                case 'FTO': return 20; // FTO is similar to 3x3 length
                default: return 20;
            }
        }

        // New scramble generation functions for WCA standards
        function generate3x3Scramble(length) {
            const faces = ["R", "L", "U", "D", "F", "B"];
            const modifiers = ["", "'", "2"];
            const axisMap = { "R": 0, "L": 0, "U": 1, "D": 1, "F": 2, "B": 2 }; // 0:RL, 1:UD, 2:FB

            let scramble = [];
            let lastAxis = -1;

            for (let i = 0; i < length; i++) {
                let currentFace;
                let currentAxis;
                do {
                    currentFace = faces[Math.floor(Math.random() * faces.length)];
                    currentAxis = axisMap[currentFace];
                } while (currentAxis === lastAxis); // Avoid same axis as last move

                let modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
                scramble.push(currentFace + modifier);
                lastAxis = currentAxis;
            }
            return scramble.join(" ");
        }

        function generate2x2Scramble(length) {
            const faces = ["R", "U", "F"];
            const modifiers = ["", "'", "2"];
            const axisMap = { "R": 0, "U": 1, "F": 2 }; // Treat each as a distinct axis for simplicity

            let scramble = [];
            let lastAxis = -1;

            for (let i = 0; i < length; i++) {
                let currentFace;
                let currentAxis;
                do {
                    currentFace = faces[Math.floor(Math.random() * faces.length)];
                    currentAxis = axisMap[currentFace];
                } while (currentAxis === lastAxis);

                let modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
                scramble.push(currentFace + modifier);
                lastAxis = currentAxis;
            }
            return scramble.join(" ");
        }

        function generateNxNScramble(eventType, length) {
            // For NxN, WCA scrambles are much more complex, involving inner layers and specific algorithms.
            // This will be a simplified version that includes wide moves and avoids same-axis consecutive moves.
            const faces = ["R", "L", "U", "D", "F", "B"];
            const wideFaces = ["Rw", "Lw", "Uw", "Dw", "Fw", "Bw"];
            const modifiers = ["", "'", "2"];
            const axisMap = {
                "R": 0, "L": 0, "Rw": 0, "Lw": 0,
                "U": 1, "D": 1, "Uw": 1, "Dw": 1,
                "F": 2, "B": 2, "Fw": 2, "Bw": 2
            };

            let scramble = [];
            let lastAxis = -1;

            for (let i = 0; i < length; i++) {
                let currentMove;
                let currentAxis;
                do {
                    const useWide = Math.random() < 0.3; // 30% chance for a wide move
                    currentMove = useWide ? wideFaces[Math.floor(Math.random() * wideFaces.length)] : faces[Math.floor(Math.random() * faces.length)];
                    currentAxis = axisMap[currentMove];
                } while (currentAxis === lastAxis);

                let modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
                scramble.push(currentMove + modifier);
                lastAxis = currentAxis;
            }
            return scramble.join(" ");
        }

        function generatePyraminxScramble(length) {
            const faceMoves = ["U", "L", "R", "B"];
            const tipMoves = ["u", "l", "r", "b"];
            const modifiers = ["", "'"]; // Pyraminx only uses prime, no '2'
            const axisMap = { "U": 0, "L": 1, "R": 2, "B": 3 }; // Treat each face as a distinct axis for avoiding consecutive same-face moves

            let scramble = [];
            let lastFaceMove = ''; // Keep track of last face move to avoid repetition
            let lastTipMove = ''; // Keep track of last tip move
            let lastAxis = -1;

            for (let i = 0; i < length; i++) {
                let moveType;
                let moveChar;
                let modifier;
                let currentAxis;

                if (Math.random() < 0.7) { // 70% chance for a face move
                    do {
                        moveChar = faceMoves[Math.floor(Math.random() * faceMoves.length)];
                        currentAxis = axisMap[moveChar];
                    } while (currentAxis === lastAxis); // Avoid same axis for face moves
                    
                    modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
                    scramble.push(moveChar + modifier);
                    lastFaceMove = moveChar;
                    lastAxis = currentAxis;
                } else { // 30% chance for a tip move
                    do {
                        moveChar = tipMoves[Math.floor(Math.random() * tipMoves.length)];
                    } while (moveChar === lastTipMove); // Avoid same tip move consecutively
                    
                    modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
                    scramble.push(moveChar + modifier);
                    lastTipMove = moveChar;
                    // Tip moves don't affect axis constraint for face moves, so don't update lastAxis
                }
            }
            return scramble.join(" ");
        }

        function generateMegaminxScramble(length) {
            // Megaminx scrambles are very specific (R/U turns with ++/-- modifiers).
            // This is a simplified WCA-like generator.
            const moves = ["R", "U"];
            const modifiers = ["++", "--"];
            let scramble = [];
            let lastMove = '';

            for (let i = 0; i < length; i++) {
                let currentMove;
                do {
                    currentMove = moves[Math.floor(Math.random() * moves.length)];
                } while (currentMove === lastMove); // Avoid R R or U U

                let modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
                scramble.push(currentMove + modifier);
                lastMove = currentMove;
            }
            return scramble.join(" ");
        }

        function generateSkewbScramble(length) {
            const moves = ["R", "U", "L", "B"]; // WCA notation for Skewb corners
            const modifiers = ["", "'"];
            let scramble = [];
            let lastAxis = -1; // R:0, U:1, L:2, B:3 (treat as distinct for avoiding repetition)
            const axisMap = { "R": 0, "U": 1, "L": 2, "B": 3 };

            for (let i = 0; i < length; i++) {
                let currentMove;
                let currentAxis;
                do {
                    currentMove = moves[Math.floor(Math.random() * moves.length)];
                    currentAxis = axisMap[currentMove];
                } while (currentAxis === lastAxis);

                let modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
                scramble.push(currentMove + modifier);
                lastAxis = currentAxis;
            }
            return scramble.join(" ");
        }

        function generateSquare1Scramble(length) {
            // Square-1 scrambles are highly specific and complex (slice turns, rotations).
            // This is a very simplified representation to match notation and length.
            // A proper Square-1 scramble generator is extremely complex.
            const topLayerMoves = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5];
            const bottomLayerMoves = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5];
            const middleSlice = "/";
            
            let scramble = [];
            let lastMoveWasSlice = false;

            for (let i = 0; i < length; i++) {
                if (!lastMoveWasSlice && Math.random() < 0.3) { // Occasionally add a middle slice
                    scramble.push(middleSlice);
                    lastMoveWasSlice = true;
                } else {
                    const top = topLayerMoves[Math.floor(Math.random() * topLayerMoves.length)];
                    const bottom = bottomLayerMoves[Math.floor(Math.random() * bottomLayerMoves.length)];
                    scramble.push(`(${top},${bottom})`);
                    lastMoveWasSlice = false;
                }
            }
            return scramble.join(" ");
        }

        function generateClockScramble(length) {
            // Clock scrambles involve pin pushes and wheel turns.
            // This is a simplified representation.
            const pinPositions = ["UR", "DR", "DL", "UL"];
            const wheelTurns = ["U", "D", "R", "L", "F", "B"]; // WCA notation for wheels
            const pinModifiers = ["+", "-"];
            const wheelModifiers = ["0", "1", "2", "3", "4", "5", "-1", "-2", "-3", "-4", "-5"]; // -5 to 5, excluding 0
            
            let scramble = [];
            for (let i = 0; i < length; i++) {
                if (Math.random() < 0.5) { // 50% chance for a pin move
                    const pin = pinPositions[Math.floor(Math.random() * pinPositions.length)];
                    const mod = pinModifiers[Math.floor(Math.random() * pinModifiers.length)];
                    scramble.push(`${pin}${mod}`);
                } else { // 50% chance for a wheel turn
                    const wheel = wheelTurns[Math.floor(Math.random() * wheelTurns.length)];
                    let mod;
                    do {
                        mod = wheelModifiers[Math.floor(Math.random() * wheelModifiers.length)];
                    } while (mod === "0"); // Avoid 0 turn
                    scramble.push(`${wheel}${mod}`);
                }
            }
            scramble.push("ALL"); // WCA scrambles often end with ALL for all pins
            const finalAllMod = pinModifiers[Math.floor(Math.random() * pinModifiers.length)];
            scramble.push(finalAllMod);
            return scramble.join(" ");
        }

        function generateFTOScramble(length) {
            // FTO scrambles are similar to 3x3 but with different faces.
            const moves = ["F", "R", "L", "B", "U", "D"]; // Common FTO moves
            const modifiers = ["", "'", "2"];
            const axisMap = { "F": 0, "R": 1, "L": 2, "B": 3, "U": 4, "D": 5 }; // Treat as distinct axes

            let scramble = [];
            let lastAxis = -1;

            for (let i = 0; i < length; i++) {
                let currentMove;
                let currentAxis;
                do {
                    currentMove = moves[Math.floor(Math.random() * moves.length)];
                    currentAxis = axisMap[currentMove];
                } while (currentAxis === lastAxis);

                let modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
                scramble.push(currentMove + modifier);
                lastAxis = currentAxis;
            }
            return scramble.join(" ");
        }


        function generateScrambleForEvent(eventType, length) {
            switch (eventType) {
                case '3x3':
                case '3x3 OH':
                case '3x3 BLD':
                case '3x3 Multi-BLD':
                    return generate3x3Scramble(length);
                case '2x2':
                    return generate2x2Scramble(length);
                case '4x4':
                case '5x5':
                case '6x6':
                case '7x7':
                    return generateNxNScramble(eventType, length);
                case 'Clock':
                    return generateClockScramble(length);
                case 'Megaminx':
                    return generateMegaminxScramble(length);
                case 'Pyraminx':
                    return generatePyraminxScramble(length);
                case 'Skewb':
                    return generateSkewbScramble(length);
                case 'Square-1':
                    return generateSquare1Scramble(length);
                case 'FTO':
                    return generateFTOScramble(length);
                default:
                    return "No scramble available for this event.";
            }
        }

        // Main scramble generation function
        function generateScramble(addToHistory = false) {
            const newScramble = generateScrambleForEvent(currentEvent, scrambleLength);
            currentScramble = newScramble;
            scrambleDisplay.textContent = newScramble;

            if (addToHistory) {
                if (currentScrambleIndex < scrambleHistory.length - 1) {
                    scrambleHistory = scrambleHistory.slice(0, currentScrambleIndex + 1);
                }
                scrambleHistory.push({ scramble: newScramble, event: currentEvent });
                currentScrambleIndex = scrambleHistory.length - 1;
            }
            updateScrambleNavButtons();
        }

        // Adjust canvas size for responsiveness (simplified, no canvas specific logic)
        function resizeCanvas() {
            // No canvas to resize, but still useful to trigger scramble generation based on event
            if (currentScrambleIndex === -1 || scrambleHistory.length === 0 || scrambleHistory[currentScrambleIndex].event !== currentEvent) {
                generateScramble(true);
            } else {
                const currentScrambleData = scrambleHistory[currentScrambleIndex];
                currentScramble = currentScrambleData.scramble;
                scrambleDisplay.textContent = currentScramble;
            }
            updateScrambleNavButtons();
        }

        // --- Event Listeners ---

        document.addEventListener('keydown', (e) => {
            if (timerMode === 'manual') return;

            if (e.code === 'Space') {
                e.preventDefault();
                if (!running && spacebarDownTime === 0) {
                    spacebarDownTime = Date.now();
                    timerDisplay.classList.add('timer-ready');
                    setTimeout(() => {
                        if (Date.now() - spacebarDownTime >= holdTimeThreshold && !running) {
                            timerDisplay.classList.remove('timer-ready');
                            timerDisplay.classList.add('timer-holding');
                            readyToStart = true;
                        }
                    }, holdTimeThreshold);
                } else if (running) {
                    stopTimer();
                    spacebarDownTime = 0;
                    readyToStart = false;
                }
            } else if (e.ctrlKey) {
                if (e.key === '2' && !running) {
                    e.preventDefault();
                    applyPlusTwoToLastSolve();
                } else if (e.key === '3' && !running) {
                    e.preventDefault();
                    applyDnfToLastSolve();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (timerMode === 'manual') return;

            if (e.code === 'Space') {
                e.preventDefault();
                if (!running && readyToStart) {
                    startTimer();
                } else if (!running && !readyToStart && spacebarDownTime > 0 && (Date.now() - spacebarDownTime < holdTimeThreshold)) {
                    resetTimer();
                }
                spacebarDownTime = 0;
                readyToStart = false;
                timerDisplay.classList.remove('timer-ready', 'timer-holding');
                if (timerMode === 'keyboard') {
                    timerDisplay.style.color = 'var(--timer-color)';
                }
            }
        });

        // --- Scramble Navigation Logic ---
        lastScrambleBtn.addEventListener('click', () => {
            if (currentScrambleIndex > 0) {
                currentScrambleIndex--;
                const scrambleData = scrambleHistory[currentScrambleIndex];
                currentScramble = scrambleData.scramble;
                scrambleDisplay.textContent = currentScramble;
                currentEvent = scrambleData.event;
                eventSelect.value = currentEvent;
                updateScrambleLengthLimits(currentEvent); // Update limits when navigating
                scrambleLengthInput.value = scrambleLength; // Update input field
                resizeCanvas(); // Still call resize to update scramble and buttons
                updateScrambleNavButtons();
            }
        });

        nextScrambleBtn.addEventListener('click', () => {
            if (currentScrambleIndex < scrambleHistory.length - 1) {
                currentScrambleIndex++;
                const scrambleData = scrambleHistory[currentScrambleIndex];
                currentScramble = scrambleData.scramble;
                scrambleDisplay.textContent = currentScramble;
                currentEvent = scrambleData.event;
                eventSelect.value = currentEvent;
                updateScrambleLengthLimits(currentEvent); // Update limits when navigating
                scrambleLengthInput.value = scrambleLength; // Update input field
                resizeCanvas(); // Still call resize to update scramble and buttons
            } else {
                generateScramble(true);
            }
            updateScrambleNavButtons();
        });

        function updateScrambleNavButtons() {
            lastScrambleBtn.disabled = currentScrambleIndex <= 0;
            nextScrambleBtn.disabled = false;
        }


        // --- Firestore Integration (updated to use currentSessionId) ---

        // Saves a solve to Firestore
        async function saveSolve(time, scramble, event, dnf = false) {
            if (!db || !userId || !isAuthReady || !currentSessionId) {
                console.warn("Firestore not initialized, user not authenticated, or no session active. Solve not saved.");
                return;
            }
            try {
                const solvesCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/sessions/${currentSessionId}/solves`);
                await addDoc(solvesCollectionRef, {
                    time: time,
                    scramble: scramble,
                    event: event,
                    timestamp: Date.now(),
                    plusTwo: false,
                    dnf: dnf
                });
                console.log("Solve saved successfully!");
            } catch (e) {
                console.error("Error adding document: ", e);
            }
        }

        // Updates a solve in Firestore
        async function updateSolveInFirestore(solveId, updates) {
            if (!db || !userId || !isAuthReady || !currentSessionId) {
                console.warn("Firestore not initialized, user not authenticated, or no session active. Solve not updated.");
                return;
            }
            try {
                const solveDocRef = doc(db, `artifacts/${appId}/users/${userId}/sessions/${currentSessionId}/solves`, solveId);
                await updateDoc(solveDocRef, updates);
                console.log("Solve updated successfully!");
            } catch (e) {
                console.error("Error updating document: ", e);
            }
        }

        // Applies +2 to the last solve
        async function applyPlusTwoToLastSolve() {
            if (solves.length === 0) {
                console.log("No solves to apply +2 to.");
                return;
            }
            const lastSolve = solves[0];
            if (lastSolve.dnf) {
                console.log("Cannot apply +2 to a DNF solve.");
                return;
            }
            if (lastSolve.plusTwo) {
                console.log("Solve already has +2 applied.");
                return;
            }

            const updatedTime = lastSolve.time + 2000;
            await updateSolveInFirestore(lastSolve.id, { time: updatedTime, plusTwo: true });
        }

        // Applies DNF to the last solve
        async function applyDnfToLastSolve() {
            if (solves.length === 0) {
                console.log("No solves to DNF.");
                return;
            }
            const lastSolve = solves[0];
            if (lastSolve.dnf) {
                console.log("Solve is already DNF.");
                return;
            }

            await updateSolveInFirestore(lastSolve.id, { dnf: true, plusTwo: false });
        }

        // Deletes a solve from Firestore
        async function deleteSolve(solveId) {
            if (!db || !userId || !isAuthReady || !currentSessionId) {
                console.warn("Firestore not initialized, user not authenticated, or no session active. Solve not deleted.");
                return;
            }
            try {
                const solveDocRef = doc(db, `artifacts/${appId}/users/${userId}/sessions/${currentSessionId}/solves`, solveId);
                await deleteDoc(solveDocRef);
                console.log("Solve deleted successfully!");
            } catch (e) {
                console.error("Error deleting document: ", e);
            }
        }

        // Loads solves from Firestore in real-time for the current session
        function loadSolvesForCurrentSession() {
            if (!db || !userId || !isAuthReady || !currentSessionId) {
                console.warn("Firestore not initialized, user not authenticated, or no session active. Solves not loaded.");
                return;
            }
            const solvesCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/sessions/${currentSessionId}/solves`);
            onSnapshot(solvesCollectionRef, (snapshot) => {
                const fetchedSolves = [];
                snapshot.forEach((doc) => {
                    fetchedSolves.push({ id: doc.id, ...doc.data() });
                });
                // Sort by timestamp in descending order (most recent first)
                solves = fetchedSolves.sort((a, b) => b.timestamp - a.timestamp);
                updateSolvesList();
                updateStatistics();
            }, (error) => {
                console.error("Error fetching solves: ", error);
            });
        }

        // --- Settings Management (updated to use currentSessionId) ---

        // Loads settings for the current session from Firestore
        async function loadSettingsForCurrentSession() {
            if (!db || !userId || !isAuthReady || !currentSessionId) {
                console.warn("Firestore not initialized, user not authenticated, or no session active. Settings not loaded.");
                return;
            }
            try {
                const sessionDocRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, currentSessionId);
                const docSnap = await getDoc(sessionDocRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    scrambleLength = data.scrambleLength || getScrambleLengthForEvent(data.currentEvent || '3x3');
                    holdTimeThreshold = data.holdTimeThreshold || 500;
                    currentEvent = data.currentEvent || '3x3';
                    timerMode = data.timerMode || 'keyboard';
                    currentTheme = data.theme || 'standard';
                    wcaId = data.wcaId || '';
                    cameraEnabled = data.cameraEnabled || false;
                    console.log("Settings loaded for session:", currentSessionName, data);
                } else {
                    console.log("No settings found for current session, using defaults.");
                    // This should ideally not happen if a session is always created with defaults
                    // but as a fallback, save defaults to the current session
                    await saveSettingsForCurrentSession();
                }
                // Update UI with loaded settings
                scrambleLengthInput.value = scrambleLength;
                holdTimeThresholdInput.value = holdTimeThreshold;
                eventSelect.value = currentEvent;
                themeSelect.value = currentTheme;
                wcaIdInput.value = wcaId;
                cameraToggle.checked = cameraEnabled;

                // Apply theme and generate scramble based on loaded settings
                applyTheme(currentTheme);
                updateScrambleLengthLimits(currentEvent); // Update min/max for scramble length input
                generateScramble(true); // Generate scramble for the loaded event
                if (cameraEnabled) {
                    enableCamera();
                } else {
                    disableCamera();
                }

            } catch (e) {
                console.error("Error loading settings for current session: ", e);
            }
        }

        // Saves settings for the current session to Firestore
        async function saveSettingsForCurrentSession() {
            if (!db || !userId || !isAuthReady || !currentSessionId) {
                console.warn("Firestore not initialized, user not authenticated, or no session active. Settings not saved.");
                return;
            }
            try {
                const sessionDocRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, currentSessionId);
                await setDoc(sessionDocRef, {
                    scrambleLength: scrambleLength,
                    holdTimeThreshold: holdTimeThreshold,
                    currentEvent: currentEvent,
                    timerMode: timerMode,
                    theme: currentTheme,
                    wcaId: wcaId,
                    cameraEnabled: cameraEnabled
                }, { merge: true });
                console.log("Settings saved successfully for session:", currentSessionName);
            } catch (e) {
                console.error("Error saving settings for current session: ", e);
            }
        }

        // Clears all solves for the current session
        async function clearAllSolvesForCurrentSession() {
            if (!db || !userId || !isAuthReady || !currentSessionId) {
                console.warn("Firestore not initialized, user not authenticated, or no session active. Cannot clear solves.");
                return;
            }
            showConfirmation("Are you sure you want to clear all solves for the current session? This action cannot be undone.", "Clear", async () => {
                try {
                    const solvesCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/sessions/${currentSessionId}/solves`);
                    const q = query(solvesCollectionRef);
                    const querySnapshot = await getDocs(q);

                    if (querySnapshot.empty) {
                        console.log("No solves to clear in this session.");
                        return;
                    }

                    const batch = writeBatch(db);
                    querySnapshot.forEach((document) => {
                        batch.delete(document.ref);
                    });
                    await batch.commit();
                    console.log("All solves cleared successfully for current session!");
                } catch (e) {
                    console.error("Error clearing all solves for current session: ", e);
                    showConfirmation("Error clearing solves. Please try again.", "OK", () => {}, true);
                }
            });
        }

        // --- UI Updates for Solves and Statistics ---

        // Updates the displayed list of solves
        function updateSolvesList() {
            solvesList.innerHTML = '';
            if (solves.length === 0) {
                solvesList.innerHTML = '<li class="text-center text-gray-400">No solves yet for this session. Start cubing!</li>';
                return;
            }
            solves.forEach(solve => {
                const li = document.createElement('li');
                li.innerHTML = `
                    <span class="solve-time">${formatTime(solve.time, solve.dnf, solve.plusTwo)}</span>
                    <span class="solve-scramble">${solve.scramble}</span>
                    <span class="text-xs text-gray-500 ml-2">(${solve.event || 'N/A'})</span>
                    <button class="delete-solve-btn" data-id="${solve.id}">Delete</button>
                `;
                solvesList.appendChild(li);
            });

            // Add event listeners for delete buttons
            solvesList.querySelectorAll('.delete-solve-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const solveId = e.target.dataset.id;
                    deleteSolve(solveId);
                });
            });
        }

        // Helper function to calculate average of N solves (WCA rules)
        function calculateAverageOfN(solvesArray, n) {
            if (solvesArray.length < n) {
                return 'N/A';
            }

            // Get the most recent 'n' solves for the current event
            const recentSolves = solvesArray
                .filter(solve => solve.event === currentEvent)
                .slice(0, n);

            if (recentSolves.length < n) {
                return 'N/A';
            }

            // Check for DNF in the window
            if (recentSolves.some(solve => solve.dnf)) {
                return 'DNF';
            }

            // Get effective times (including +2)
            let times = recentSolves.map(solve => solve.time + (solve.plusTwo ? 2000 : 0));
            
            // Sort times to drop best and worst
            times.sort((a, b) => a - b);

            let sum = 0;
            // For N >= 3, drop the best and worst. For N < 3, average all.
            const startIndex = (n >= 3) ? 1 : 0;
            const endIndex = (n >= 3) ? n - 1 : n;

            for (let i = startIndex; i < endIndex; i++) {
                sum += times[i];
            }

            const count = endIndex - startIndex;
            if (count === 0) return 'N/A';

            return formatTime(sum / count);
        }

        // Helper function to calculate the best average of 5
        function calculateBestAverageOf5(solvesArray) {
            const eventSolves = solvesArray.filter(solve => solve.event === currentEvent);
            if (eventSolves.length < 5) {
                return 'N/A';
            }

            let bestAvg = Infinity;
            let foundValidAvg = false;

            // Iterate through all possible contiguous groups of 5 solves
            // The solves array is already sorted by timestamp descending, so we need to iterate backwards
            // to get the "last 5", then "last 6-2", etc.
            // For "best average", we look at all possible windows of 5.
            for (let i = 0; i <= eventSolves.length - 5; i++) {
                const windowSolves = eventSolves.slice(i, i + 5);

                // Check for DNF in this window
                if (windowSolves.some(solve => solve.dnf)) {
                    continue;
                }

                let times = windowSolves.map(solve => solve.time + (solve.plusTwo ? 2000 : 0));
                times.sort((a, b) => a - b);

                // Drop best and worst
                const currentAvg = (times[1] + times[2] + times[3]) / 3;

                if (currentAvg < bestAvg) {
                    bestAvg = currentAvg;
                    foundValidAvg = true;
                }
            }

            return foundValidAvg ? formatTime(bestAvg) : 'N/A';
        }


        // Updates the statistics display
        function updateStatistics() {
            // Filter solves for the current event
            const currentEventSolves = solves.filter(solve => solve.event === currentEvent);
            
            totalSolvesDisplay.textContent = currentEventSolves.length;

            const validSolvesForCurrentEvent = currentEventSolves.filter(solve => !solve.dnf);

            if (validSolvesForCurrentEvent.length > 0) {
                const totalTime = validSolvesForCurrentEvent.reduce((sum, solve) => sum + solve.time, 0);
                const averageTime = totalTime / validSolvesForCurrentEvent.length;
                averageTimeDisplay.textContent = formatTime(averageTime);

                const bestTime = Math.min(...validSolvesForCurrentEvent.map(solve => solve.time));
                bestTimeDisplay.textContent = formatTime(bestTime);
            } else {
                averageTimeDisplay.textContent = 'N/A';
                bestTimeDisplay.textContent = 'N/A';
            }

            // Update new averages
            bestAo5Display.textContent = calculateBestAverageOf5(solves);
            ao12Display.textContent = calculateAverageOfN(solves, 12);
            ao25Display.textContent = calculateAverageOfN(solves, 25);
            ao50Display.textContent = calculateAverageOfN(solves, 50);
            ao100Display.textContent = calculateAverageOfN(solves, 100);
            ao200Display.textContent = calculateAverageOfN(solves, 200);
            ao500Display.textContent = calculateAverageOfN(solves, 500);
        }

        // --- Modal Management (Helper) ---
        function closeAllModals() {
            settingsModal.classList.remove('open');
            quickEventDropdown.classList.remove('open');
            sessionsModal.classList.remove('open'); // Close sessions modal
            confirmationModal.classList.remove('open');
            cameraPermissionModal.classList.remove('open');
            eventSelect.classList.add('hidden');
            document.body.appendChild(eventSelect); // Move eventSelect back to body
        }

        function showConfirmation(message, confirmBtnText, onConfirm, isAlert = false) {
            confirmationMessage.textContent = message;
            confirmActionButton.textContent = confirmBtnText;
            confirmActionButton.onclick = () => {
                onConfirm();
                confirmationModal.classList.remove('open');
                currentConfirmAction = null;
            };
            cancelActionButton.onclick = () => {
                confirmationModal.classList.remove('open');
                currentConfirmAction = null;
            };

            if (isAlert) {
                cancelActionButton.classList.add('hidden');
                confirmActionButton.classList.add('w-full');
            } else {
                cancelActionButton.classList.remove('hidden');
                confirmActionButton.classList.remove('w-full');
            }

            confirmationModal.classList.add('open');
        }


        // --- Settings Modal Event Listeners ---
        settingsBtn.addEventListener('click', () => {
            closeAllModals();
            settingsModal.classList.add('open');
            settingsModal.querySelector('.settings-section:nth-of-type(2)').appendChild(eventSelect);
            eventSelect.classList.remove('hidden');
        });

        closeSettingsBtn.addEventListener('click', () => {
            closeAllModals();
        });

        // Close settings modal if clicking outside content
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                closeAllModals();
            }
        });

        // --- Quick Event Dropdown Event Listeners ---
        quickEventToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (quickEventDropdown.classList.contains('open')) {
                closeAllModals();
            } else {
                closeAllModals();
                quickEventDropdown.classList.add('open');
                quickEventDropdown.querySelector('.modal-body').prepend(eventSelect);
                eventSelect.classList.remove('hidden');
            }
        });

        closeQuickEventBtn.addEventListener('click', () => {
            closeAllModals();
        });

        // Close quick event dropdown if clicking outside content
        quickEventDropdown.addEventListener('click', (e) => {
            if (e.target === quickEventDropdown) {
                closeAllModals();
            }
        });

        // Close any open modal/dropdown if clicking anywhere else on the document
        document.addEventListener('click', (e) => {
            if (!settingsModal.contains(e.target) && !quickEventDropdown.contains(e.target) && !sessionsModal.contains(e.target) &&
                e.target !== settingsBtn && e.target !== quickEventToggleBtn && e.target !== sessionsBtn &&
                !confirmationModal.contains(e.target) && !cameraPermissionModal.contains(e.target)) {
                closeAllModals();
            }
        });


        // Update settings on input change
        scrambleLengthInput.addEventListener('change', () => {
            scrambleLength = parseInt(scrambleLengthInput.value);
            // Ensure scramble length is within valid range for the current event
            const { min, max } = getScrambleLengthRange(currentEvent);
            if (isNaN(scrambleLength) || scrambleLength < min) scrambleLength = min;
            if (scrambleLength > max) scrambleLength = max;
            scrambleLengthInput.value = scrambleLength;
            saveSettingsForCurrentSession();
            generateScramble(true);
        });

        holdTimeThresholdInput.addEventListener('change', () => {
            holdTimeThreshold = parseInt(holdTimeThresholdInput.value);
            if (isNaN(holdTimeThreshold) || holdTimeThreshold < 100) holdTimeThreshold = 100;
            if (holdTimeThreshold > 2000) holdTimeThreshold = 2000;
            holdTimeThresholdInput.value = holdTimeThreshold;
            saveSettingsForCurrentSession();
        });

        // Helper to get scramble length range based on event
        function getScrambleLengthRange(eventType) {
            switch (eventType) {
                case '2x2': return { min: 5, max: 20 };
                case '3x3':
                case '3x3 OH':
                case '3x3 BLD':
                case '3x3 Multi-BLD': return { min: 10, max: 50 };
                case '4x4': return { min: 30, max: 60 };
                case '5x5': return { min: 50, max: 80 };
                case '6x6': return { min: 70, max: 100 };
                case '7x7': return { min: 90, max: 120 };
                case 'Clock': return { min: 5, max: 20 };
                case 'Megaminx': return { min: 50, max: 90 };
                case 'Pyraminx': return { min: 5, max: 20 };
                case 'Skewb': return { min: 5, max: 20 };
                case 'Square-1': return { min: 5, max: 20 };
                case 'FTO': return { min: 10, max: 50 };
                default: return { min: 10, max: 50 };
            }
        }

        // Updates min/max attributes for scramble length input
        function updateScrambleLengthLimits(eventType) {
            const range = getScrambleLengthRange(eventType);
            scrambleLengthInput.min = range.min;
            scrambleLengthInput.max = range.max;
            // Adjust current scrambleLength if it falls outside new range
            if (scrambleLength < range.min) scrambleLength = range.min;
            if (scrambleLength > range.max) scrambleLength = range.max;
            scrambleLengthInput.value = scrambleLength;
        }

        // Event listener for the dynamically moved eventSelect
        eventSelect.addEventListener('change', () => {
            currentEvent = eventSelect.value;
            updateScrambleLengthLimits(currentEvent); // Update limits based on new event
            saveSettingsForCurrentSession();
            generateScramble(true);
            resizeCanvas(); // Still call resize to update scramble and buttons
            closeAllModals();
        });

        // New theme select event listener
        themeSelect.addEventListener('change', () => {
            const newTheme = themeSelect.value;
            applyTheme(newTheme);
            saveSettingsForCurrentSession();
            // No need to regenerate scramble here, as it's not drawn.
        });

        // WCA ID Save button listener
        saveWcaIdBtn.addEventListener('click', () => {
            wcaId = wcaIdInput.value.trim();
            saveSettingsForCurrentSession();
            updateWCAIdDisplay();
        });

        function updateWCAIdDisplay() {
            if (wcaId) {
                wcaIdDisplay.textContent = `WCA ID: ${wcaId}`;
            } else {
                wcaIdDisplay.textContent = 'WCA ID: N/A';
            }
        }


        // Manual time entry logic (for the input in the settings modal)
        addManualSolveBtn.addEventListener('click', () => {
            addManualSolveFromInput(manualTimeInput.value);
            manualTimeInput.value = '';
        });

        manualTimeInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                addManualSolveFromInput(manualTimeInput.value);
                manualTimeInput.value = '';
            }
        });

        // New manual time entry logic for the main input
        manualTimerMainInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                addManualSolveFromInput(manualTimerMainInput.value);
                manualTimerMainInput.value = '';
            }
        });

        function parseManualTime(timeString) {
            timeString = timeString.trim();
            if (!timeString) return null;

            if (timeString.toUpperCase() === 'DNF') {
                return 'DNF';
            }

            if (/^\d+$/.test(timeString)) {
                const num = parseInt(timeString, 10);
                return num * 10;
            }

            let totalMilliseconds = 0;
            const parts = timeString.split(':');

            if (parts.length === 1) {
                const secondsPart = parseFloat(parts[0]);
                if (isNaN(secondsPart)) return null;
                totalMilliseconds = Math.round(secondsPart * 1000);
            } else if (parts.length === 2) {
                const minutes = parseInt(parts[0]);
                const secondsPart = parseFloat(parts[1]);
                if (isNaN(minutes) || isNaN(secondsPart)) return null;
                totalMilliseconds = (minutes * 60 * 1000) + Math.round(secondsPart * 1000);
            } else {
                return null;
            }

            return totalMilliseconds;
        }

        async function addManualSolveFromInput(timeString) {
            const parsedTime = parseManualTime(timeString);

            if (parsedTime === null) {
                console.error("Invalid time format. Please use SS.mmm, MM:SS.mmm, or a pure number (e.g., 10.5, 1:23.456, or 12345 for 12.345).");
                return;
            }

            if (parsedTime === 'DNF') {
                await saveSolve(0, currentScramble, currentEvent, true);
            } else {
                await saveSolve(parsedTime, currentScramble, currentEvent);
            }
            generateScramble(true);
        }

        clearSolvesBtn.addEventListener('click', () => {
            clearAllSolvesForCurrentSession();
            settingsModal.classList.remove('open');
        });

        // --- Confirmation Modal Event Listeners ---
        closeConfirmationBtn.addEventListener('click', () => {
            confirmationModal.classList.remove('open');
        });

        cancelActionButton.addEventListener('click', () => {
            confirmationModal.classList.remove('open');
        });

        // confirmActionButton's listener is set dynamically in showConfirmation

        confirmationModal.addEventListener('click', (e) => {
            if (e.target === confirmationModal) {
                confirmationModal.classList.remove('open');
            }
        });

        // --- Timer Mode Toggle Logic ---
        toggleTimerModeBtn.addEventListener('click', () => {
            timerMode = (timerMode === 'keyboard') ? 'manual' : 'keyboard';
            saveSettingsForCurrentSession();
            updateTimerModeUI();
            resetTimer();
        });

        function updateTimerModeUI() {
            if (timerMode === 'keyboard') {
                toggleTimerModeBtn.textContent = 'Switch to Manual Entry';
                timerDisplay.classList.remove('hidden');
                manualTimerMainInput.classList.add('hidden');
                timerDisplay.style.color = 'var(--timer-color)';
            } else {
                toggleTimerModeBtn.textContent = 'Switch to Keyboard Timer';
                timerDisplay.classList.add('hidden');
                manualTimerMainInput.classList.remove('hidden');
                manualTimerMainInput.value = '';
                manualTimerMainInput.classList.add('timer-manual-mode');
                manualTimerMainInput.style.color = 'var(--manual-mode-color)';
            }
        }

        // --- Camera Logic ---
        cameraToggle.addEventListener('change', () => {
            cameraEnabled = cameraToggle.checked;
            if (cameraEnabled) {
                enableCamera();
            } else {
                disableCamera();
            }
            saveSettingsForCurrentSession();
        });

        async function enableCamera() {
            if (mediaStream) {
                cameraFeed.srcObject = mediaStream;
                cameraFeed.classList.remove('hidden');
                startRecordingBtn.disabled = false;
                return;
            }
            try {
                // Request both video and audio
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                mediaStream = stream;
                cameraFeed.srcObject = stream;
                cameraFeed.classList.remove('hidden');
                console.log("Camera and microphone enabled.");

                // Initialize MediaRecorder with the stream (including audio)
                mediaRecorder = new MediaRecorder(stream);
                recordedChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `solve_${Date.now()}.webm`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    recordedChunks = [];
                    console.log("Recording stopped and downloaded.");
                    recordingStatusDisplay.classList.add('hidden');
                };

                startRecordingBtn.disabled = false;
                stopRecordingBtn.disabled = true;

            } catch (err) {
                console.error("Error accessing camera/microphone: ", err);
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    showCameraPermissionDeniedModal();
                } else {
                    console.error("Other camera/microphone access error:", err);
                }
                cameraEnabled = false;
                cameraToggle.checked = false;
                saveSettingsForCurrentSession();
                startRecordingBtn.disabled = true;
                stopRecordingBtn.disabled = true;
            }
        }

        function disableCamera() {
            if (mediaStream) {
                if (recording) {
                    stopRecording();
                }
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
                mediaRecorder = null;
            }
            cameraFeed.srcObject = null;
            cameraFeed.classList.add('hidden');
            console.log("Camera disabled.");
            startRecordingBtn.disabled = true;
            stopRecordingBtn.disabled = true;
            recordingStatusDisplay.classList.add('hidden');
        }

        // Function to show the camera permission denied modal
        function showCameraPermissionDeniedModal() {
            closeAllModals();
            cameraPermissionModal.classList.add('open');
        }

        // Event listeners for the camera permission denied modal
        closeCameraPermissionModalBtn.addEventListener('click', () => {
            cameraPermissionModal.classList.remove('open');
        });

        okCameraPermissionBtn.addEventListener('click', () => {
            cameraPermissionModal.classList.remove('open');
        });


        // Recording functionality
        startRecordingBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'inactive') {
                recordedChunks = [];
                mediaRecorder.start();
                recording = true;
                startRecordingBtn.disabled = true;
                stopRecordingBtn.disabled = false;
                recordingStatusDisplay.classList.remove('hidden');
                console.log("Recording started.");
            } else {
                console.warn("MediaRecorder is not ready or already recording.");
            }
        });

        stopRecordingBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                recording = false;
                startRecordingBtn.disabled = false;
                stopRecordingBtn.disabled = true;
                console.log("Recording stopped.");
            } else {
                console.warn("MediaRecorder is not recording.");
            }
        });

        // --- AI Analysis for Start Position ---

        async function analyzeStartImage() {
            if (!cameraEnabled || !mediaStream || cameraFeed.readyState !== 4) {
                aiFeedbackDisplay.textContent = "Camera not active for AI analysis.";
                aiFeedbackDisplay.classList.add('error');
                return;
            }

            aiFeedbackDisplay.textContent = "Analyzing start position...";
            aiFeedbackDisplay.classList.remove('error'); // Clear error class

            // Ensure canvas dimensions match video for capture
            captureCanvas.width = cameraFeed.videoWidth;
            captureCanvas.height = cameraFeed.videoHeight;
            captureCtx.drawImage(cameraFeed, 0, 0, captureCanvas.width, cameraFeed.videoHeight);
            
            // Get image data as Base64
            const base64ImageData = captureCanvas.toDataURL('image/jpeg').split(',')[1]; // Remove "data:image/jpeg;base64," prefix

            if (!base64ImageData) {
                aiFeedbackDisplay.textContent = "Failed to capture image for AI analysis.";
                aiFeedbackDisplay.classList.add('error');
                return;
            }

            try {
                let chatHistory = [];
                const prompt = "Analyze the hand placement in this image for a speedcubing timer start. Is it a good, neutral, or bad starting position? Provide a concise reason (1-2 sentences). Focus on hand readiness, finger position, and overall posture for a quick and fair start. Avoid mentioning the cube itself unless it's directly related to hand placement (e.g., hands already on the cube).";
                
                const payload = {
                    contents: [
                        {
                            role: "user",
                            parts: [
                                { text: prompt },
                                {
                                    inlineData: {
                                        mimeType: "image/jpeg",
                                        data: base64ImageData
                                    }
                                }
                            ]
                        }
                    ],
                };

                const apiKey = ""; // Canvas will automatically provide this in runtime
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    aiFeedbackDisplay.textContent = `AI Feedback: ${text}`;
                    aiFeedbackDisplay.classList.remove('error'); // Clear error class
                } else {
                    aiFeedbackDisplay.textContent = "AI analysis failed: No valid response.";
                    aiFeedbackDisplay.classList.add('error');
                    console.error("AI analysis failed: Unexpected API response structure", result);
                }
            } catch (error) {
                aiFeedbackDisplay.textContent = "AI analysis error: Could not connect to service.";
                aiFeedbackDisplay.classList.add('error');
                console.error("Error calling Gemini API for image analysis:", error);
            }
        }


        // --- Initial Setup ---
        window.onload = () => {
            if (Object.keys(firebaseConfig).length === 0) {
                // If no Firebase config, manually initialize UI elements
                generateScramble(true);
                updateTimerModeUI();
                applyTheme(currentTheme);
                updateWCAIdDisplay();
                currentSessionNameDisplay.textContent = `Session: ${currentSessionName}`;
            }
            resizeCanvas(); // This now only updates scramble text and nav buttons
            updateScrambleNavButtons();
            
            startRecordingBtn.disabled = !cameraEnabled;
            stopRecordingBtn.disabled = true;
        };

        window.addEventListener('resize', resizeCanvas);

        // --- Sessions Modal Event Listeners ---
        sessionsBtn.addEventListener('click', () => {
            closeAllModals();
            sessionsModal.classList.add('open');
            updateSessionsListUI(); // Ensure list is updated when modal opens
        });

        closeSessionsBtn.addEventListener('click', () => {
            closeAllModals();
        });

        sessionsModal.addEventListener('click', (e) => {
            if (e.target === sessionsModal) {
                closeAllModals();
            }
        });

        createSessionBtn.addEventListener('click', async () => {
            const name = newSessionNameInput.value.trim();
            if (name) {
                await createSession(name);
                newSessionNameInput.value = '';
                // The onSnapshot listener will automatically update the UI and select the new session
            } else {
                alert("Please enter a session name.");
            }
        });

    </script>
</body>
</html>
